<{ DateIntraction: 2018-02-05T19:36:36.970Z, _id: 5a78b26b09ac380a8f643cce, name: 'Himanshu Kumar', username: 'himanshukumar660' },members,function () { return this.toObject({ transform: false, virtuals: false, _skipDepopulateTopLevel: true, depopulate: true, flattenDecimals: false }); },[object Object],{ _id: 5a78b26b09ac380a8f643ccd, dateMade: 2018-02-05T19:37:15.035Z, userId: 'tafuD5', name: 'NIT Durgapur', alert: 'West Bengal', aboutUs: 'Official', __v: 0, score: 0.75, pendingRequest: [], admin: [ { username: 'himanshukumar660', name: 'Himanshu Kumar', _id: 5a78b26b09ac380a8f643ccf, DateIntraction: 2018-02-05T19:36:36.970Z } ], members: [ { username: 'himanshukumar660', name: 'Himanshu Kumar', _id: 5a78b26b09ac380a8f643cce, DateIntraction: 2018-02-05T19:36:36.970Z } ] },function (value, index) { var Constructor = this._schema.casterConstructor; if (value instanceof Constructor || // Hack re: #5001, see #5005 (value && value.constructor && value.constructor.baseCasterConstructor === Constructor)) { if (!(value.__parent && value.__parentArray)) { // value may have been created using array.create() value.__parent = this._parent; value.__parentArray = this; } value.__index = index; return value; } if (value === undefined || value === null) { return null; } // handle cast('string') or cast(ObjectId) etc. // only objects are permitted so we can safely assume that // non-objects are to be interpreted as _id if (Buffer.isBuffer(value) || value instanceof ObjectId || !utils.isObject(value)) { value = {_id: value}; } if (value && Constructor.discriminators && Constructor.schema.options.discriminatorKey && typeof value[Constructor.schema.options.discriminatorKey] === 'string' && Constructor.discriminators[value[Constructor.schema.options.discriminatorKey]]) { Constructor = Constructor.discriminators[value[Constructor.schema.options.discriminatorKey]]; } return new Constructor(value, this, undefined, undefined, index); },function (elem, embeddedPath) { var parent = this._parent, dirtyPath; if (parent) { dirtyPath = this._path; if (arguments.length) { if (embeddedPath != null) { // an embedded doc bubbled up the change dirtyPath = dirtyPath + '.' + this.indexOf(elem) + '.' + embeddedPath; } else { // directly set an index dirtyPath = dirtyPath + '.' + elem; } } parent.markModified(dirtyPath, arguments.length > 0 ? elem : parent); } return this; },function (op, val) { if (op === '$set') { // $set takes precedence over all other ops. // mark entire array modified. this._atomics = {$set: val}; return this; } var atomics = this._atomics; // reset pop/shift after save if (op === '$pop' && !('$pop' in atomics)) { var _this = this; this._parent.once('save', function() { _this._popped = _this._shifted = null; }); } // check for impossible $atomic combos (Mongo denies more than one // $atomic op on a single path if (this._atomics.$set || Object.keys(atomics).length && !(op in atomics)) { // a different op was previously registered. // save the entire thing. this._atomics = {$set: this}; return this; } var selector; if (op === '$pullAll' || op === '$pushAll' || op === '$addToSet') { atomics[op] || (atomics[op] = []); atomics[op] = atomics[op].concat(val); } else if (op === '$pullDocs') { var pullOp = atomics['$pull'] || (atomics['$pull'] = {}); if (val[0] instanceof EmbeddedDocument) { selector = pullOp['$or'] || (pullOp['$or'] = []); Array.prototype.push.apply(selector, val.map(function(v) { return v.toObject({transform: false, virtuals: false}); })); } else { selector = pullOp['_id'] || (pullOp['_id'] = {$in: []}); selector['$in'] = selector['$in'].concat(val); } } else { atomics[op] = val; } return this; },function () { var ret = []; var keys = Object.keys(this._atomics); var i = keys.length; if (i === 0) { ret[0] = ['$set', this.toObject({depopulate: 1, transform: false, _isNested: true, virtuals: false})]; return ret; } while (i--) { var op = keys[i]; var val = this._atomics[op]; // the atomic values which are arrays are not MongooseArrays. we // need to convert their elements as if they were MongooseArrays // to handle populated arrays versus DocumentArrays properly. if (isMongooseObject(val)) { val = val.toObject({depopulate: 1, transform: false, _isNested: true, virtuals: false}); } else if (Array.isArray(val)) { val = this.toObject.call(val, {depopulate: 1, transform: false, _isNested: true}); } else if (val.valueOf) { val = val.valueOf(); } if (op === '$addToSet') { val = {$each: val}; } ret.push([op, val]); } return ret; },function hasAtomics() { if (!(this._atomics && this._atomics.constructor.name === 'Object')) { return 0; } return Object.keys(this._atomics).length; },function (val, index) { return this._cast(val, this.length + index); },function () { _checkManualPopulation(this, arguments); var values = [].map.call(arguments, this._mapCast, this); values = this._schema.applySetters(values, this._parent, undefined, undefined, { skipDocumentArrayCast: true }); var ret = [].push.apply(this, values); // $pushAll might be fibbed (could be $push). But it makes it easier to // handle what could have been $push, $pushAll combos this._registerAtomic('$pushAll', values); this._markModified(); return ret; },function () { var values = [].map.call(arguments, this._mapCast, this); var ret = [].push.apply(this, values); this._registerAtomic('$set', this); this._markModified(); return ret; },function () { this._registerAtomic('$pop', 1); this._markModified(); // only allow popping once if (this._popped) { return; } this._popped = true; return [].pop.call(this); },function () { var ret = [].pop.call(this); this._registerAtomic('$set', this); this._markModified(); return ret; },function $shift() { this._registerAtomic('$pop', -1); this._markModified(); // only allow shifting once if (this._shifted) { return; } this._shifted = true; return [].shift.call(this); },function () { var ret = [].shift.call(this); this._registerAtomic('$set', this); this._markModified(); return ret; },function () { var values = [].map.call(arguments, this._cast, this), cur = this._parent.get(this._path), i = cur.length, mem; while (i--) { mem = cur[i]; if (mem instanceof Document) { var some = values.some(function(v) { return mem.equals(v); }); if (some) { [].splice.call(cur, i, 1); } } else if (~cur.indexOf.call(values, mem)) { [].splice.call(cur, i, 1); } } if (values[0] instanceof EmbeddedDocument) { this._registerAtomic('$pullDocs', values.map(function(v) { return v._id || v; })); } else { this._registerAtomic('$pullAll', values); } this._markModified(); // Might have modified child paths and then pulled, like // `doc.children[1].name = 'test';` followed by // `doc.children.remove(doc.children[0]);`. In this case we fall back // to a `$set` on the whole array. See #3511 if (cleanModifiedSubpaths(this._parent, this._path) > 0) { this._registerAtomic('$set', this); } return this; },function splice() { var ret; var vals; var i; _checkManualPopulation(this, Array.prototype.slice.call(arguments, 2)); if (arguments.length) { vals = []; for (i = 0; i < arguments.length; ++i) { vals[i] = i < 2 ? arguments[i] : this._cast(arguments[i], arguments[0] + (i - 2)); } ret = [].splice.apply(this, vals); this._registerAtomic('$set', this); this._markModified(); } return ret; },function () { _checkManualPopulation(this, arguments); var values = [].map.call(arguments, this._cast, this); values = this._schema.applySetters(values, this._parent); [].unshift.apply(this, values); this._registerAtomic('$set', this); this._markModified(); return this.length; },function () { var ret = [].sort.apply(this, arguments); this._registerAtomic('$set', this); this._markModified(); return ret; },function addToSet() { _checkManualPopulation(this, arguments); var values = [].map.call(arguments, this._mapCast, this); values = this._schema.applySetters(values, this._parent); var added = []; var type = ''; if (values[0] instanceof EmbeddedDocument) { type = 'doc'; } else if (values[0] instanceof Date) { type = 'date'; } values.forEach(function(v) { var found; switch (type) { case 'doc': found = this.some(function(doc) { return doc.equals(v); }); break; case 'date': var val = +v; found = this.some(function(d) { return +d === val; }); break; default: found = ~this.indexOf(v); } if (!found) { [].push.call(this, v); this._registerAtomic('$addToSet', v); this._markModified(); [].push.call(added, v); } }, this); return added; },function set(i, val) { var value = this._cast(val, i); this[i] = value; this._markModified(i); return this; },function (options) { return this.map(function(doc) { return doc && doc.toObject(options) || null; }); },function () { return Array.prototype.slice.call(this); },function indexOf(obj) { if (obj instanceof ObjectId) { obj = obj.toString(); } for (var i = 0, len = this.length; i < len; ++i) { if (obj == this[i]) { return i; } } return -1; },function () { var values = [].map.call(arguments, this._cast, this), cur = this._parent.get(this._path), i = cur.length, mem; while (i--) { mem = cur[i]; if (mem instanceof Document) { var some = values.some(function(v) { return mem.equals(v); }); if (some) { [].splice.call(cur, i, 1); } } else if (~cur.indexOf.call(values, mem)) { [].splice.call(cur, i, 1); } } if (values[0] instanceof EmbeddedDocument) { this._registerAtomic('$pullDocs', values.map(function(v) { return v._id || v; })); } else { this._registerAtomic('$pullAll', values); } this._markModified(); // Might have modified child paths and then pulled, like // `doc.children[1].name = 'test';` followed by // `doc.children.remove(doc.children[0]);`. In this case we fall back // to a `$set` on the whole array. See #3511 if (cleanModifiedSubpaths(this._parent, this._path) > 0) { this._registerAtomic('$set', this); } return this; },function (id) { var casted, sid, _id; try { var casted_ = ObjectIdSchema.prototype.cast.call({}, id); if (casted_) { casted = String(casted_); } } catch (e) { casted = null; } for (var i = 0, l = this.length; i < l; i++) { if (!this[i]) { continue; } _id = this[i].get('_id'); if (_id === null || typeof _id === 'undefined') { continue; } else if (_id instanceof Document) { sid || (sid = String(id)); if (sid == _id._id) { return this[i]; } } else if (!(id instanceof ObjectId) && !(_id instanceof ObjectId)) { if (utils.deepEqual(id, _id)) { return this[i]; } } else if (casted == _id) { return this[i]; } } return null; },function (obj) { var Constructor = this._schema.casterConstructor; if (obj && Constructor.discriminators && Constructor.schema.options.discriminatorKey && typeof obj[Constructor.schema.options.discriminatorKey] === 'string' && Constructor.discriminators[obj[Constructor.schema.options.discriminatorKey]]) { Constructor = Constructor.discriminators[obj[Constructor.schema.options.discriminatorKey]]; } return new Constructor(obj); },function notify(event) { var _this = this; return function notify(val) { var i = _this.length; while (i--) { if (!_this[i]) { continue; } switch (event) { // only swap for save event for now, we may change this to all event types later case 'save': val = _this[i]; break; default: // NO-OP break; } _this[i].emit(event, val); } }; },true,true,,[object Object],[object Object]> 0 ? elem : parent); } return this; },function (op, val) { if (op === '$set') { // $set takes precedence over all other ops. // mark entire array modified. this._atomics = {$set: val}; return this; } var atomics = this._atomics; // reset pop/shift after save if (op === '$pop' && !('$pop' in atomics)) { var _this = this; this._parent.once('save', function() { _this._popped = _this._shifted = null; }); } // check for impossible $atomic combos (Mongo denies more than one // $atomic op on a single path if (this._atomics.$set || Object.keys(atomics).length && !(op in atomics)) { // a different op was previously registered. // save the entire thing. this._atomics = {$set: this}; return this; } var selector; if (op === '$pullAll' || op === '$pushAll' || op === '$addToSet') { atomics[op] || (atomics[op] = []); atomics[op] = atomics[op].concat(val); } else if (op === '$pullDocs') { var pullOp = atomics['$pull'] || (atomics['$pull'] = {}); if (val[0] instanceof EmbeddedDocument) { selector = pullOp['$or'] || (pullOp['$or'] = []); Array.prototype.push.apply(selector, val.map(function(v) { return v.toObject({transform: false, virtuals: false}); })); } else { selector = pullOp['_id'] || (pullOp['_id'] = {$in: []}); selector['$in'] = selector['$in'].concat(val); } } else { atomics[op] = val; } return this; },function () { var ret = []; var keys = Object.keys(this._atomics); var i = keys.length; if (i === 0) { ret[0] = ['$set', this.toObject({depopulate: 1, transform: false, _isNested: true, virtuals: false})]; return ret; } while (i--) { var op = keys[i]; var val = this._atomics[op]; // the atomic values which are arrays are not MongooseArrays. we // need to convert their elements as if they were MongooseArrays // to handle populated arrays versus DocumentArrays properly. if (isMongooseObject(val)) { val = val.toObject({depopulate: 1, transform: false, _isNested: true, virtuals: false}); } else if (Array.isArray(val)) { val = this.toObject.call(val, {depopulate: 1, transform: false, _isNested: true}); } else if (val.valueOf) { val = val.valueOf(); } if (op === '$addToSet') { val = {$each: val}; } ret.push([op, val]); } return ret; },function hasAtomics() { if (!(this._atomics && this._atomics.constructor.name === 'Object')) { return 0; } return Object.keys(this._atomics).length; },function (val, index) { return this._cast(val, this.length + index); },function () { _checkManualPopulation(this, arguments); var values = [].map.call(arguments, this._mapCast, this); values = this._schema.applySetters(values, this._parent, undefined, undefined, { skipDocumentArrayCast: true }); var ret = [].push.apply(this, values); // $pushAll might be fibbed (could be $push). But it makes it easier to // handle what could have been $push, $pushAll combos this._registerAtomic('$pushAll', values); this._markModified(); return ret; },function () { var values = [].map.call(arguments, this._mapCast, this); var ret = [].push.apply(this, values); this._registerAtomic('$set', this); this._markModified(); return ret; },function () { this._registerAtomic('$pop', 1); this._markModified(); // only allow popping once if (this._popped) { return; } this._popped = true; return [].pop.call(this); },function () { var ret = [].pop.call(this); this._registerAtomic('$set', this); this._markModified(); return ret; },function $shift() { this._registerAtomic('$pop', -1); this._markModified(); // only allow shifting once if (this._shifted) { return; } this._shifted = true; return [].shift.call(this); },function () { var ret = [].shift.call(this); this._registerAtomic('$set', this); this._markModified(); return ret; },function () { var values = [].map.call(arguments, this._cast, this), cur = this._parent.get(this._path), i = cur.length, mem; while (i--) { mem = cur[i]; if (mem instanceof Document) { var some = values.some(function(v) { return mem.equals(v); }); if (some) { [].splice.call(cur, i, 1); } } else if (~cur.indexOf.call(values, mem)) { [].splice.call(cur, i, 1); } } if (values[0] instanceof EmbeddedDocument) { this._registerAtomic('$pullDocs', values.map(function(v) { return v._id || v; })); } else { this._registerAtomic('$pullAll', values); } this._markModified(); // Might have modified child paths and then pulled, like // `doc.children[1].name = 'test';` followed by // `doc.children.remove(doc.children[0]);`. In this case we fall back // to a `$set` on the whole array. See #3511 if (cleanModifiedSubpaths(this._parent, this._path) > 0) { this._registerAtomic('$set', this); } return this; },function splice() { var ret; var vals; var i; _checkManualPopulation(this, Array.prototype.slice.call(arguments, 2)); if (arguments.length) { vals = []; for (i = 0; i < arguments.length; ++i) { vals[i] = i < 2 ? arguments[i] : this._cast(arguments[i], arguments[0] + (i - 2)); } ret = [].splice.apply(this, vals); this._registerAtomic('$set', this); this._markModified(); } return ret; },function () { _checkManualPopulation(this, arguments); var values = [].map.call(arguments, this._cast, this); values = this._schema.applySetters(values, this._parent); [].unshift.apply(this, values); this._registerAtomic('$set', this); this._markModified(); return this.length; },function () { var ret = [].sort.apply(this, arguments); this._registerAtomic('$set', this); this._markModified(); return ret; },function addToSet() { _checkManualPopulation(this, arguments); var values = [].map.call(arguments, this._mapCast, this); values = this._schema.applySetters(values, this._parent); var added = []; var type = ''; if (values[0] instanceof EmbeddedDocument) { type = 'doc'; } else if (values[0] instanceof Date) { type = 'date'; } values.forEach(function(v) { var found; switch (type) { case 'doc': found = this.some(function(doc) { return doc.equals(v); }); break; case 'date': var val = +v; found = this.some(function(d) { return +d === val; }); break; default: found = ~this.indexOf(v); } if (!found) { [].push.call(this, v); this._registerAtomic('$addToSet', v); this._markModified(); [].push.call(added, v); } }, this); return added; },function set(i, val) { var value = this._cast(val, i); this[i] = value; this._markModified(i); return this; },function (options) { return this.map(function(doc) { return doc && doc.toObject(options) || null; }); },function () { return Array.prototype.slice.call(this); },function indexOf(obj) { if (obj instanceof ObjectId) { obj = obj.toString(); } for (var i = 0, len = this.length; i < len; ++i) { if (obj == this[i]) { return i; } } return -1; },function () { var values = [].map.call(arguments, this._cast, this), cur = this._parent.get(this._path), i = cur.length, mem; while (i--) { mem = cur[i]; if (mem instanceof Document) { var some = values.some(function(v) { return mem.equals(v); }); if (some) { [].splice.call(cur, i, 1); } } else if (~cur.indexOf.call(values, mem)) { [].splice.call(cur, i, 1); } } if (values[0] instanceof EmbeddedDocument) { this._registerAtomic('$pullDocs', values.map(function(v) { return v._id || v; })); } else { this._registerAtomic('$pullAll', values); } this._markModified(); // Might have modified child paths and then pulled, like // `doc.children[1].name = 'test';` followed by // `doc.children.remove(doc.children[0]);`. In this case we fall back // to a `$set` on the whole array. See #3511 if (cleanModifiedSubpaths(this._parent, this._path) > 0) { this._registerAtomic('$set', this); } return this; },function (id) { var casted, sid, _id; try { var casted_ = ObjectIdSchema.prototype.cast.call({}, id); if (casted_) { casted = String(casted_); } } catch (e) { casted = null; } for (var i = 0, l = this.length; i < l; i++) { if (!this[i]) { continue; } _id = this[i].get('_id'); if (_id === null || typeof _id === 'undefined') { continue; } else if (_id instanceof Document) { sid || (sid = String(id)); if (sid == _id._id) { return this[i]; } } else if (!(id instanceof ObjectId) && !(_id instanceof ObjectId)) { if (utils.deepEqual(id, _id)) { return this[i]; } } else if (casted == _id) { return this[i]; } } return null; },function (obj) { var Constructor = this._schema.casterConstructor; if (obj && Constructor.discriminators && Constructor.schema.options.discriminatorKey && typeof obj[Constructor.schema.options.discriminatorKey] === 'string' && Constructor.discriminators[obj[Constructor.schema.options.discriminatorKey]]) { Constructor = Constructor.discriminators[obj[Constructor.schema.options.discriminatorKey]]; } return new Constructor(obj); },function notify(event) { var _this = this; return function notify(val) { var i = _this.length; while (i--) { if (!_this[i]) { continue; } switch (event) { // only swap for save event for now, we may change this to all event types later case 'save': val = _this[i]; break; default: // NO-OP break; } _this[i].emit(event, val); } }; },true,true,,[object Object],[object Object]>